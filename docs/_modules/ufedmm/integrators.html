
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ufedmm.integrators &#8212; UFED for OpenMM  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for ufedmm.integrators</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">.. module:: integrators</span>
<span class="sd">   :platform: Unix, Windows</span>
<span class="sd">   :synopsis: Unified Free Energy Dynamics Integrators</span>

<span class="sd">.. moduleauthor:: Charlles Abreu &lt;abreu@eq.ufrj.br&gt;</span>

<span class="sd">.. _Context: http://docs.openmm.org/latest/api-python/generated/openmm.openmm.Context.html</span>
<span class="sd">.. _CustomCVForce: http://docs.openmm.org/latest/api-python/generated/openmm.openmm.CustomCVForce.html</span>
<span class="sd">.. _CustomIntegrator: http://docs.openmm.org/latest/api-python/generated/openmm.openmm.CustomIntegrator.html</span>
<span class="sd">.. _Force: http://docs.openmm.org/latest/api-python/generated/openmm.openmm.Force.html</span>
<span class="sd">.. _NonbondedForce: http://docs.openmm.org/latest/api-python/generated/openmm.openmm.NonbondedForce.html</span>
<span class="sd">.. _System: http://docs.openmm.org/latest/api-python/generated/openmm.openmm.System.html</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">openmm</span>
<span class="kn">from</span> <span class="nn">openmm</span> <span class="kn">import</span> <span class="n">unit</span>

<span class="kn">from</span> <span class="nn">ufedmm.ufedmm</span> <span class="kn">import</span> <span class="n">_standardized</span>


<div class="viewcode-block" id="add_inner_nonbonded_force"><a class="viewcode-back" href="../../pythonapi/integrators.html#ufedmm.integrators.add_inner_nonbonded_force">[docs]</a><span class="k">def</span> <span class="nf">add_inner_nonbonded_force</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">inner_switch</span><span class="p">,</span> <span class="n">inner_cutoff</span><span class="p">,</span> <span class="n">force_group_index</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To a given OpenMM System_ containing a NonbondedForce_ object, this function adds a new force</span>
<span class="sd">    group with the purpose of performing multiple time-scale integration according to the RESPA2</span>
<span class="sd">    splitting scheme of Morrone, Zhou, and Berne :cite:`Morrone_2010`. Besides, it assigns the</span>
<span class="sd">    provided `force_group_index` to this new group and `force_group_index+1` to the original</span>
<span class="sd">    NonbondedForce_. When used in any instance of :class:`AbstractMiddleRespaIntegrator`, the new</span>
<span class="sd">    force group must be identified as being embodied by the NonbondedForce_ as opposed to being</span>
<span class="sd">    complimentary to it.</span>

<span class="sd">    .. warning:</span>
<span class="sd">        The new force group is not intended to contribute to the system energy. Its sole purpose</span>
<span class="sd">        is to provide a smooth, short-range force calculator for some intermediary time scale in</span>
<span class="sd">        a RESPA-type integration.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        system : openmm.System</span>
<span class="sd">            The system the inner force will be added to, which must contain a NonbondedForce_.</span>
<span class="sd">        inner_switch : float or unit.Quantity</span>
<span class="sd">            The inner switching distance, where the interaction of an atom pair begins to switch</span>
<span class="sd">            off to zero.</span>
<span class="sd">        inner_cutoff : float or unit.Quantity</span>
<span class="sd">            The inner cutoff distance, where the interaction of an atom pairs completely switches</span>
<span class="sd">            off.</span>
<span class="sd">        force_group_index : int</span>
<span class="sd">            The force group the new interactions will belong to. The old NonbondedForce_ will be</span>
<span class="sd">            automatically assigned to `force_group_index+1`.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">        &gt;&gt;&gt; import ufedmm</span>
<span class="sd">        &gt;&gt;&gt; from openmm import unit</span>
<span class="sd">        &gt;&gt;&gt; dt = 2*unit.femtoseconds</span>
<span class="sd">        &gt;&gt;&gt; temp = 300*unit.kelvin</span>
<span class="sd">        &gt;&gt;&gt; tau = 10*unit.femtoseconds</span>
<span class="sd">        &gt;&gt;&gt; gamma = 10/unit.picoseconds</span>
<span class="sd">        &gt;&gt;&gt; model = ufedmm.AlanineDipeptideModel()</span>
<span class="sd">        &gt;&gt;&gt; ufedmm.add_inner_nonbonded_force(model.system, 5*unit.angstroms, 8*unit.angstroms, 1)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">openmm</span><span class="o">.</span><span class="n">__version__</span> <span class="o">&lt;</span> <span class="s2">&quot;7.5&quot;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;add_inner_nonbonded_force requires OpenMM version &gt;= 7.5&quot;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">nonbonded_force</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span>
            <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">openmm</span><span class="o">.</span><span class="n">NonbondedForce</span><span class="p">),</span> <span class="n">system</span><span class="o">.</span><span class="n">getForces</span><span class="p">())</span>
        <span class="p">)</span>
    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;add_inner_nonbonded_force requires system with NonbondedForce&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="n">nonbonded_force</span><span class="o">.</span><span class="n">getNumParticleParameterOffsets</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="ow">or</span> <span class="n">nonbonded_force</span><span class="o">.</span><span class="n">getNumExceptionParameterOffsets</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;add_inner_nonbonded_force does not support parameter offsets&quot;</span><span class="p">)</span>
    <span class="n">periodic</span> <span class="o">=</span> <span class="n">nonbonded_force</span><span class="o">.</span><span class="n">usesPeriodicBoundaryConditions</span><span class="p">()</span>
    <span class="n">rs</span> <span class="o">=</span> <span class="n">_standardized</span><span class="p">(</span><span class="n">inner_switch</span><span class="p">)</span>
    <span class="n">rc</span> <span class="o">=</span> <span class="n">_standardized</span><span class="p">(</span><span class="n">inner_cutoff</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">rc</span> <span class="o">+</span> <span class="n">rs</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">rc</span> <span class="o">*</span> <span class="n">rs</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="mi">30</span> <span class="o">/</span> <span class="p">(</span><span class="n">rc</span> <span class="o">-</span> <span class="n">rs</span><span class="p">)</span> <span class="o">**</span> <span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">b</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">f0s</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">c</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">rs</span> <span class="o">**</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">coeff</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">c</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">n</span> <span class="k">else</span> <span class="n">c</span><span class="p">[</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;*log(r)&quot;</span> <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="n">n</span> <span class="k">else</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;*r^</span><span class="si">{</span><span class="n">m</span><span class="o">-</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="k">else</span> <span class="sa">f</span><span class="s2">&quot;/r^</span><span class="si">{</span><span class="n">n</span><span class="o">-</span><span class="n">m</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">val</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">f0s</span> <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">(</span><span class="n">coeff</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">-</span> <span class="n">coeff</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">m</span> <span class="k">else</span> <span class="n">coeff</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">sgn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;+&quot;</span> <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">val</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">S</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">sgn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span><span class="si">}{</span><span class="n">val</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span><span class="si">}{</span><span class="n">func</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>

    <span class="n">potential</span> <span class="o">=</span> <span class="s2">&quot;eps4*((sigma/r)^12-(sigma/r)^6)+Qprod/r&quot;</span>
    <span class="n">potential</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;+step(r-</span><span class="si">{</span><span class="n">rs</span><span class="si">}</span><span class="s2">)*(eps4*(sigma^12*(</span><span class="si">{</span><span class="n">S</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span><span class="si">}</span><span class="s2">)-sigma^6*(</span><span class="si">{</span><span class="n">S</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span><span class="si">}</span><span class="s2">))+Qprod*(</span><span class="si">{</span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s2">))&quot;</span>
    <span class="n">mixing_rules</span> <span class="o">=</span> <span class="s2">&quot;; Qprod=Q1*Q2&quot;</span>
    <span class="n">mixing_rules</span> <span class="o">+=</span> <span class="s2">&quot;; sigma=halfsig1+halfsig2&quot;</span>
    <span class="n">mixing_rules</span> <span class="o">+=</span> <span class="s2">&quot;; eps4=sqrt4eps1*sqrt4eps2&quot;</span>
    <span class="n">force</span> <span class="o">=</span> <span class="n">openmm</span><span class="o">.</span><span class="n">CustomNonbondedForce</span><span class="p">(</span><span class="n">potential</span> <span class="o">+</span> <span class="n">mixing_rules</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Q&quot;</span><span class="p">,</span> <span class="s2">&quot;halfsig&quot;</span><span class="p">,</span> <span class="s2">&quot;sqrt4eps&quot;</span><span class="p">]:</span>
        <span class="n">force</span><span class="o">.</span><span class="n">addPerParticleParameter</span><span class="p">(</span><span class="n">parameter</span><span class="p">)</span>
    <span class="n">force</span><span class="o">.</span><span class="n">setNonbondedMethod</span><span class="p">(</span><span class="n">force</span><span class="o">.</span><span class="n">CutoffPeriodic</span> <span class="k">if</span> <span class="n">periodic</span> <span class="k">else</span> <span class="n">force</span><span class="o">.</span><span class="n">CutoffNonPeriodic</span><span class="p">)</span>
    <span class="n">force</span><span class="o">.</span><span class="n">setCutoffDistance</span><span class="p">(</span><span class="n">inner_cutoff</span><span class="p">)</span>
    <span class="n">force</span><span class="o">.</span><span class="n">setUseLongRangeCorrection</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">ONE_4PI_EPS0</span> <span class="o">=</span> <span class="mf">138.93545764438198</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nonbonded_force</span><span class="o">.</span><span class="n">getNumParticles</span><span class="p">()):</span>
        <span class="n">charge</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">_standardized</span><span class="p">,</span> <span class="n">nonbonded_force</span><span class="o">.</span><span class="n">getParticleParameters</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
        <span class="n">force</span><span class="o">.</span><span class="n">addParticle</span><span class="p">([</span><span class="n">charge</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ONE_4PI_EPS0</span><span class="p">),</span> <span class="n">sigma</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">epsilon</span><span class="p">)])</span>
    <span class="n">non_exclusion_exceptions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nonbonded_force</span><span class="o">.</span><span class="n">getNumExceptions</span><span class="p">()):</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">q1q2</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="n">nonbonded_force</span><span class="o">.</span><span class="n">getExceptionParameters</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">q1q2</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">_standardized</span><span class="p">,</span> <span class="p">[</span><span class="n">q1q2</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">])</span>
        <span class="n">force</span><span class="o">.</span><span class="n">addExclusion</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">q1q2</span> <span class="o">!=</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">epsilon</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">non_exclusion_exceptions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">q1q2</span> <span class="o">*</span> <span class="n">ONE_4PI_EPS0</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">epsilon</span><span class="p">))</span>
    <span class="n">force</span><span class="o">.</span><span class="n">setForceGroup</span><span class="p">(</span><span class="n">force_group_index</span><span class="p">)</span>
    <span class="n">system</span><span class="o">.</span><span class="n">addForce</span><span class="p">(</span><span class="n">force</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">non_exclusion_exceptions</span><span class="p">:</span>
        <span class="n">exceptions</span> <span class="o">=</span> <span class="n">openmm</span><span class="o">.</span><span class="n">CustomBondForce</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;step(</span><span class="si">{</span><span class="n">rc</span><span class="si">}</span><span class="s2">-r)*(</span><span class="si">{</span><span class="n">potential</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">parameter</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Qprod&quot;</span><span class="p">,</span> <span class="s2">&quot;sigma&quot;</span><span class="p">,</span> <span class="s2">&quot;eps4&quot;</span><span class="p">]:</span>
            <span class="n">exceptions</span><span class="o">.</span><span class="n">addPerBondParameter</span><span class="p">(</span><span class="n">parameter</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">Qprod</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">eps4</span> <span class="ow">in</span> <span class="n">non_exclusion_exceptions</span><span class="p">:</span>
            <span class="n">exceptions</span><span class="o">.</span><span class="n">addBond</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">[</span><span class="n">Qprod</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">eps4</span><span class="p">])</span>
        <span class="n">exceptions</span><span class="o">.</span><span class="n">setForceGroup</span><span class="p">(</span><span class="n">force_group_index</span><span class="p">)</span>
        <span class="n">system</span><span class="o">.</span><span class="n">addForce</span><span class="p">(</span><span class="n">exceptions</span><span class="p">)</span>
    <span class="n">nonbonded_force</span><span class="o">.</span><span class="n">setForceGroup</span><span class="p">(</span><span class="n">force_group_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="CustomIntegrator"><a class="viewcode-back" href="../../pythonapi/integrators.html#ufedmm.integrators.CustomIntegrator">[docs]</a><span class="k">class</span> <span class="nc">CustomIntegrator</span><span class="p">(</span><span class="n">openmm</span><span class="o">.</span><span class="n">CustomIntegrator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An extension of OpenMM&#39;s CustomIntegrator_ class with an extra per-dof variable named</span>
<span class="sd">    `temperature`, whose content is the temperature of the heat bath associated to each</span>
<span class="sd">    degree of freedom. A per-dof temperature is necessary if the extended-space variables</span>
<span class="sd">    and the physical system are coupled adiabatically to thermostats at different temperatures.</span>
<span class="sd">    Otherwise, any other OpenMM integrator can be used.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        temperature : float or unit.Quantity</span>
<span class="sd">            The temperature.</span>
<span class="sd">        step_size : float or unit.Quantity</span>
<span class="sd">            The step size with which to integrate the equations of motion.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">temperature</span><span class="p">,</span> <span class="n">step_size</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">step_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">temperature</span> <span class="o">=</span> <span class="n">temperature</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addPerDofVariable</span><span class="p">(</span><span class="s2">&quot;kT&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="o">.</span><span class="n">MOLAR_GAS_CONSTANT_R</span> <span class="o">*</span> <span class="n">temperature</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_up_to_date</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A human-readable version of each integrator step (adapted from openmmtools)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        readable_lines : str</span>
<span class="sd">           A list of human-readable versions of each step of the integrator</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">readable_lines</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">getNumPerDofVariables</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">readable_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Per-dof variables:&quot;</span><span class="p">)</span>
        <span class="n">per_dof</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getNumPerDofVariables</span><span class="p">()):</span>
            <span class="n">per_dof</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getPerDofVariableName</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
        <span class="n">readable_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;  &quot;</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">per_dof</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">getNumGlobalVariables</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">readable_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Global variables:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getNumGlobalVariables</span><span class="p">()):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getGlobalVariableName</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getGlobalVariable</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
            <span class="n">readable_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">readable_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Computation steps:&quot;</span><span class="p">)</span>

        <span class="n">step_type_str</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;</span><span class="si">{target}</span><span class="s2"> &lt;- </span><span class="si">{expr}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="s2">&quot;</span><span class="si">{target}</span><span class="s2"> &lt;- </span><span class="si">{expr}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="s2">&quot;</span><span class="si">{target}</span><span class="s2"> &lt;- sum(</span><span class="si">{expr}</span><span class="s2">)&quot;</span><span class="p">,</span>
            <span class="s2">&quot;constrain positions&quot;</span><span class="p">,</span>
            <span class="s2">&quot;constrain velocities&quot;</span><span class="p">,</span>
            <span class="s2">&quot;allow forces to update the context state&quot;</span><span class="p">,</span>
            <span class="s2">&quot;if (</span><span class="si">{expr}</span><span class="s2">):&quot;</span><span class="p">,</span>
            <span class="s2">&quot;while (</span><span class="si">{expr}</span><span class="s2">):&quot;</span><span class="p">,</span>
            <span class="s2">&quot;end&quot;</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="n">indent_level</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getNumComputations</span><span class="p">()):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">step_type</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getComputationStep</span><span class="p">(</span><span class="n">step</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">step_type</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="n">indent_level</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">command</span> <span class="o">=</span> <span class="n">step_type_str</span><span class="p">[</span><span class="n">step_type</span><span class="p">]</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">,</span> <span class="n">expr</span><span class="o">=</span><span class="n">expr</span><span class="p">)</span>
            <span class="n">line</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{:4d}</span><span class="s2">: &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">step</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;   &quot;</span> <span class="o">*</span> <span class="n">indent_level</span> <span class="o">+</span> <span class="n">command</span>
            <span class="k">if</span> <span class="n">step_type</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]:</span>
                <span class="n">indent_level</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">readable_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">readable_lines</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update_temperatures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system_temperature</span><span class="p">,</span> <span class="n">extended_space_temperatures</span><span class="p">):</span>
        <span class="n">nparticles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">getPerDofVariableByName</span><span class="p">(</span><span class="s2">&quot;kT&quot;</span><span class="p">))</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">extended_space_temperatures</span><span class="p">)</span>
        <span class="n">temperatures</span> <span class="o">=</span> <span class="p">[</span><span class="n">system_temperature</span><span class="p">]</span> <span class="o">*</span> <span class="n">nparticles</span> <span class="o">+</span> <span class="n">extended_space_temperatures</span>
        <span class="n">kT</span> <span class="o">=</span> <span class="p">[</span><span class="n">unit</span><span class="o">.</span><span class="n">MOLAR_GAS_CONSTANT_R</span> <span class="o">*</span> <span class="n">T</span> <span class="o">*</span> <span class="n">openmm</span><span class="o">.</span><span class="n">Vec3</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">T</span> <span class="ow">in</span> <span class="n">temperatures</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setPerDofVariableByName</span><span class="p">(</span><span class="s2">&quot;kT&quot;</span><span class="p">,</span> <span class="n">kT</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_up_to_date</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="CustomIntegrator.step"><a class="viewcode-back" href="../../pythonapi/integrators.html#ufedmm.integrators.CustomIntegrator.step">[docs]</a>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_up_to_date</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_temperatures</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">temperature</span><span class="p">,</span> <span class="p">[])</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="AbstractMiddleRespaIntegrator"><a class="viewcode-back" href="../../pythonapi/integrators.html#ufedmm.integrators.AbstractMiddleRespaIntegrator">[docs]</a><span class="k">class</span> <span class="nc">AbstractMiddleRespaIntegrator</span><span class="p">(</span><span class="n">CustomIntegrator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An abstract class for middle-type, multiple time-scale integrators.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        This class is meant for inheritance only and does not actually include thermostatting.</span>
<span class="sd">        Concrete subclasses are available, such as :class:`MiddleMassiveNHCIntegrator` and</span>
<span class="sd">        :class:`GeodesicLangevinIntegrator`, for instance.</span>

<span class="sd">    Child classes will differ by the thermostat algorithm, which must be implemented</span>
<span class="sd">    by overriding the `_bath` method (see the example below).</span>
<span class="sd">    Temperature is treated as a per-dof parameter so as to allow adiabatic simulations.</span>

<span class="sd">    The following :term:`ODE` system is solved for every degree of freedom in the system,</span>
<span class="sd">    with possibly :math:`n_c` holonomic constraints and with forces possibly split into</span>
<span class="sd">    :math:`m` parts according to their characteristic time scales:</span>

<span class="sd">    .. math::</span>
<span class="sd">        &amp; \\dot{r}_i = v_i \\\\</span>
<span class="sd">        &amp; \\dot{v}_i = \\frac{\\sum_{k=1}^m F_i^{[k]}}{m_i}</span>
<span class="sd">                     + \\sum_{k=1}^{n_c} \\lambda_k \\nabla_{r_i} \\sigma_k</span>
<span class="sd">                     + \\mathrm{bath}(T_i, v_i) \\\\</span>
<span class="sd">        &amp; \\sigma_k(\\mathbf{r}) = 0</span>

<span class="sd">    An approximate solution is obtained by applying the Trotter-Suzuki splitting formula.</span>
<span class="sd">    In the particular case of two time scales, the default splitting scheme goes as follows:</span>

<span class="sd">    .. math::</span>
<span class="sd">        e^{\\Delta t\\mathcal{L}} =</span>
<span class="sd">            e^{\\frac{\\Delta t}{2}\\mathcal{L}^{[1]}_v}</span>
<span class="sd">            \\left[</span>
<span class="sd">                e^{\\frac{\\Delta t}{2 n_0}\\mathcal{L}^{[0]}_v}</span>
<span class="sd">                \\left(</span>
<span class="sd">                    e^{\\frac{\\Delta t}{2 n_0 n_b}\\mathcal{L}_r}</span>
<span class="sd">                    e^{\\frac{\\Delta t}{n_0 n_b}\\mathcal{L}_\\mathrm{bath}}</span>
<span class="sd">                    e^{\\frac{\\Delta t}{2 n_0 n_b}\\mathcal{L}_r}</span>
<span class="sd">                \\right)^{n_b}</span>
<span class="sd">                e^{\\frac{\\Delta t}{2 n_0}\\mathcal{L}^{[0]}_v}</span>
<span class="sd">            \\right]^{n_0}</span>
<span class="sd">            e^{\\frac{\\Delta t}{2}\\mathcal{L}^{[1]}_v}</span>

<span class="sd">    Each exponential operator is the solution of a particular subsystem of equations.</span>
<span class="sd">    If :math:`\\mathrm{bath}(T_i, v_i) = 0`, the scheme above is time-reversible, measure-preserving,</span>
<span class="sd">    and symplectic. It is referred to as the ``VV-Middle`` scheme :cite:`Zhang_2019`, where VV</span>
<span class="sd">    stands for Velocity Verlet. An alternative approach is also available, which is:</span>

<span class="sd">    .. math::</span>
<span class="sd">        e^{\\Delta t\\mathcal{L}} =</span>
<span class="sd">            \\left[</span>
<span class="sd">                \\left(</span>
<span class="sd">                    e^{\\frac{\\Delta t}{2 n_0 n_b}\\mathcal{L}_r}</span>
<span class="sd">                    e^{\\frac{\\Delta t}{n_0 n_b}\\mathcal{L}_\\mathrm{bath}}</span>
<span class="sd">                    e^{\\frac{\\Delta t}{2 n_0 n_b}\\mathcal{L}_r}</span>
<span class="sd">                \\right)^{n_b}</span>
<span class="sd">                e^{\\frac{\\Delta t}{n_0}\\mathcal{L}^{[0]}_v}</span>
<span class="sd">            \\right]^{n_0}</span>
<span class="sd">            e^{\\Delta t \\mathcal{L}^{[1]}_v}</span>

<span class="sd">    This is referred to as the ``LF-Middle`` scheme :cite:`Zhang_2019`, where LF stands for</span>
<span class="sd">    Leap-Frog. In contrast to the previous scheme, it is not time-reversible. However, in single</span>
<span class="sd">    time-scale simulations, the two approaches result in equivalent coordinate trajectories,</span>
<span class="sd">    while the latter provides a velocity trajectory more consistent with the Maxwell-Boltzmann</span>
<span class="sd">    distribution at the specified temperature :cite:`Zhang_2019`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        temperature : unit.Quantity</span>
<span class="sd">            The temperature of the heat bath.</span>
<span class="sd">        step_size : float or unit.Quantity</span>
<span class="sd">            The outer step size with which to integrate the equations of motion.</span>

<span class="sd">    Keyword Args</span>
<span class="sd">    ------------</span>
<span class="sd">        num_rattles : int, default=0</span>
<span class="sd">            The number of RATTLE computations for geodesic integration :cite:`Leimkuhler_2016`.</span>
<span class="sd">            If ``num_rattles=0``, then no constraints are considered at all.</span>
<span class="sd">        scheme : str, default=&#39;VV-Middle&#39;</span>
<span class="sd">            Which splitting scheme will be used. Valid options are &#39;VV-Middle&#39; and &#39;LF-Middle&#39;.</span>
<span class="sd">        respa_loops : list(int), default=[1]</span>
<span class="sd">            A list of `m` integers, where `respa_loops[k]` determines how many substeps with</span>
<span class="sd">            force group `k` are internally executed for every step with force group `k+1`.</span>
<span class="sd">        bath_loops : int, default=1</span>
<span class="sd">            The number of iterations of the bath operator per each step at time scale `0`. This</span>
<span class="sd">            is useful when the bath operator is not exact, but derived from a splitting solution.</span>
<span class="sd">        embodied_force_groups : list(int), default=[]</span>
<span class="sd">            A list of indices of force groups. The presence of an index `i` is this list means that</span>
<span class="sd">            the contribution of force group `i` is embodied in force group `i+1`. Therefore, such</span>
<span class="sd">            contribution must be properly subtracted during the integration at time scale `i+1`.</span>
<span class="sd">            This feature requires OpenMM 7.5 or a newer version.</span>
<span class="sd">        unroll_loops : bool, default=True</span>
<span class="sd">            Whether the integrator loops should be unrolled for improving efficiency. Using</span>
<span class="sd">            ``unroll_loops=False`` can be useful for printing the integrator steps.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">        &gt;&gt;&gt; from ufedmm import integrators</span>
<span class="sd">        &gt;&gt;&gt; from openmm import unit</span>
<span class="sd">        &gt;&gt;&gt; class MiddleNoseHooverIntegrator(integrators.AbstractMiddleRespaIntegrator):</span>
<span class="sd">        ...     def __init__(self, ndof, tau, temperature, step_size, num_rattles=1):</span>
<span class="sd">        ...         super().__init__(temperature, step_size, num_rattles, &#39;VV-Middle&#39;, [1], 1)</span>
<span class="sd">        ...         kB = 8.3144626E-3*unit.kilojoules_per_mole/unit.kelvin</span>
<span class="sd">        ...         gkT = ndof*unit.MOLAR_GAS_CONSTANT_R*temperature</span>
<span class="sd">        ...         self.addGlobalVariable(&#39;gkT&#39;, gkT)</span>
<span class="sd">        ...         self.addGlobalVariable(&#39;Q&#39;, gkT*tau**2)</span>
<span class="sd">        ...         self.addGlobalVariable(&#39;v_eta&#39;, 0)</span>
<span class="sd">        ...         self.addGlobalVariable(&#39;twoK&#39;, 0)</span>
<span class="sd">        ...         self.addGlobalVariable(&#39;scaling&#39;, 1)</span>
<span class="sd">        ...     def _bath(self, fraction):</span>
<span class="sd">        ...         self.addComputeSum(&#39;twoK&#39;, &#39;m*v*v&#39;)</span>
<span class="sd">        ...         self.addComputeGlobal(&#39;v_eta&#39;, f&#39;v_eta + {0.5*fraction}*dt*(twoK - gkT)/Q&#39;)</span>
<span class="sd">        ...         self.addComputeGlobal(&#39;scaling&#39;, f&#39;exp(-{fraction}*dt*v_eta)&#39;)</span>
<span class="sd">        ...         self.addComputePerDof(&#39;v&#39;, f&#39;v*scaling&#39;)</span>
<span class="sd">        ...         self.addComputeGlobal(&#39;v_eta&#39;, f&#39;v_eta + {0.5*fraction}*dt*(scaling^2*twoK - gkT)/Q&#39;)</span>
<span class="sd">        &gt;&gt;&gt; integrator = MiddleNoseHooverIntegrator(500, 10*unit.femtoseconds, 300*unit.kelvin,</span>
<span class="sd">        ...                                         1*unit.femtoseconds, num_rattles=0)</span>
<span class="sd">        &gt;&gt;&gt; print(integrator)</span>
<span class="sd">        Per-dof variables:</span>
<span class="sd">          kT</span>
<span class="sd">        Global variables:</span>
<span class="sd">          gkT = 1247.169392722986</span>
<span class="sd">          Q = 0.1247169392722986</span>
<span class="sd">          v_eta = 0.0</span>
<span class="sd">          twoK = 0.0</span>
<span class="sd">          scaling = 1.0</span>
<span class="sd">        Computation steps:</span>
<span class="sd">           0: allow forces to update the context state</span>
<span class="sd">           1: v &lt;- v + 0.5*dt*f/m</span>
<span class="sd">           2: x &lt;- x + 0.5*dt*v</span>
<span class="sd">           3: twoK &lt;- sum(m*v*v)</span>
<span class="sd">           4: v_eta &lt;- v_eta + 0.5*dt*(twoK - gkT)/Q</span>
<span class="sd">           5: scaling &lt;- exp(-1.0*dt*v_eta)</span>
<span class="sd">           6: v &lt;- v*scaling</span>
<span class="sd">           7: v_eta &lt;- v_eta + 0.5*dt*(scaling^2*twoK - gkT)/Q</span>
<span class="sd">           8: x &lt;- x + 0.5*dt*v</span>
<span class="sd">           9: v &lt;- v + 0.5*dt*f/m</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">temperature</span><span class="p">,</span>
        <span class="n">step_size</span><span class="p">,</span>
        <span class="n">num_rattles</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">scheme</span><span class="o">=</span><span class="s2">&quot;VV-Middle&quot;</span><span class="p">,</span>
        <span class="n">respa_loops</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">bath_loops</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">intertwine</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">embodied_force_groups</span><span class="o">=</span><span class="p">[],</span>
        <span class="n">unroll_loops</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">scheme</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;LF-Middle&quot;</span><span class="p">,</span> <span class="s2">&quot;VV-Middle&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid value </span><span class="si">{</span><span class="n">scheme</span><span class="si">}</span><span class="s2"> for keyword scheme&quot;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">temperature</span><span class="p">,</span> <span class="n">step_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_rattles</span> <span class="o">=</span> <span class="n">num_rattles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scheme</span> <span class="o">=</span> <span class="n">scheme</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_respa_loops</span> <span class="o">=</span> <span class="n">respa_loops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bath_loops</span> <span class="o">=</span> <span class="n">bath_loops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_intertwine</span> <span class="o">=</span> <span class="n">intertwine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subtractive_groups</span> <span class="o">=</span> <span class="n">embodied_force_groups</span>
        <span class="n">num_rattles</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">addPerDofVariable</span><span class="p">(</span><span class="s2">&quot;x0&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">num_rattles</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">addGlobalVariable</span><span class="p">(</span><span class="s2">&quot;irattle&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">unroll_loops</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">scale</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">respa_loops</span><span class="p">):</span>
                <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">addGlobalVariable</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;irespa</span><span class="si">{</span><span class="n">scale</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">bath_loops</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">addGlobalVariable</span><span class="p">(</span><span class="s2">&quot;ibath&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">embodied_force_groups</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">openmm</span><span class="o">.</span><span class="n">__version__</span> <span class="o">&lt;</span> <span class="s2">&quot;7.5&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Use of `embodied_force_groups` option requires OpenMM &gt;= 7.5&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addPerDofVariable</span><span class="p">(</span><span class="s2">&quot;f_emb&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">integration_groups</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">respa_loops</span><span class="p">)))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">embodied_force_groups</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setIntegrationForceGroups</span><span class="p">(</span><span class="n">integration_groups</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">addUpdateContextState</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_initialization</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">unroll_loops</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_integrate_respa_unrolled</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">respa_loops</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_integrate_respa</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">respa_loops</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step_initialization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_integrate_respa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fraction</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_respa_loops</span><span class="p">[</span><span class="n">scale</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">addComputeGlobal</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;irespa</span><span class="si">{</span><span class="n">scale</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">beginWhileBlock</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;irespa</span><span class="si">{</span><span class="n">scale</span><span class="si">}</span><span class="s2"> &lt; </span><span class="si">{</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_boost</span><span class="p">(</span><span class="n">fraction</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scheme</span> <span class="o">==</span> <span class="s2">&quot;VV-Middle&quot;</span> <span class="k">else</span> <span class="n">n</span><span class="p">),</span> <span class="n">scale</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_integrate_respa</span><span class="p">(</span><span class="n">fraction</span> <span class="o">/</span> <span class="n">n</span><span class="p">,</span> <span class="n">scale</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scheme</span> <span class="o">==</span> <span class="s2">&quot;VV-Middle&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boost</span><span class="p">(</span><span class="n">fraction</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">),</span> <span class="n">scale</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">addComputeGlobal</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;irespa</span><span class="si">{</span><span class="n">scale</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;irespa</span><span class="si">{</span><span class="n">scale</span><span class="si">}</span><span class="s2"> + 1&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">endBlock</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_intertwine</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_translation</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">fraction</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bath_loops</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">addComputeGlobal</span><span class="p">(</span><span class="s2">&quot;ibath&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">beginWhileBlock</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ibath &lt; </span><span class="si">{</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_intertwine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_translation</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">fraction</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bath</span><span class="p">(</span><span class="n">fraction</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_num_rattles</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">addConstrainVelocities</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_intertwine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_translation</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">fraction</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">addComputeGlobal</span><span class="p">(</span><span class="s2">&quot;ibath&quot;</span><span class="p">,</span> <span class="s2">&quot;ibath + 1&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">endBlock</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_intertwine</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_translation</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">fraction</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_integrate_respa_unrolled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fraction</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">scale</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_respa_loops</span><span class="p">[</span><span class="n">scale</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_boost</span><span class="p">(</span>
                    <span class="n">fraction</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scheme</span> <span class="o">==</span> <span class="s2">&quot;VV-Middle&quot;</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">n</span><span class="p">),</span> <span class="n">scale</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_integrate_respa_unrolled</span><span class="p">(</span><span class="n">fraction</span> <span class="o">/</span> <span class="n">n</span><span class="p">,</span> <span class="n">scale</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_scheme</span> <span class="o">==</span> <span class="s2">&quot;VV-Middle&quot;</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boost</span><span class="p">(</span>
                    <span class="n">fraction</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">),</span> <span class="n">scale</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bath_loops</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_intertwine</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_translation</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">fraction</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_intertwine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_translation</span><span class="p">(</span><span class="n">fraction</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">n</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_bath</span><span class="p">(</span><span class="n">fraction</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_num_rattles</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">addConstrainVelocities</span><span class="p">()</span>
                <span class="n">i</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_intertwine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_translation</span><span class="p">(</span><span class="n">fraction</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_intertwine</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_translation</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">fraction</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_translation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fraction</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_rattles</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addComputeGlobal</span><span class="p">(</span><span class="s2">&quot;irattle&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beginWhileBlock</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;irattle &lt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_rattles</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addComputePerDof</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;x + </span><span class="si">{</span><span class="n">fraction</span><span class="o">/</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_rattles</span><span class="p">)</span><span class="si">}</span><span class="s2">*dt*v&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_rattles</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addComputePerDof</span><span class="p">(</span><span class="s2">&quot;x0&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addConstrainPositions</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addComputePerDof</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;v + (x - x0)/(</span><span class="si">{</span><span class="n">fraction</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_rattles</span><span class="si">}</span><span class="s2">*dt)&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addConstrainVelocities</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_rattles</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addComputeGlobal</span><span class="p">(</span><span class="s2">&quot;irattle&quot;</span><span class="p">,</span> <span class="s2">&quot;irattle + 1&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">endBlock</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_boost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fraction</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_respa_loops</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">scale</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subtractive_groups</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">addComputePerDof</span><span class="p">(</span><span class="s2">&quot;f_emb&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;f</span><span class="si">{</span><span class="n">scale</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">addComputePerDof</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;v + </span><span class="si">{</span><span class="n">fraction</span><span class="si">}</span><span class="s2">*dt*(f</span><span class="si">{</span><span class="n">scale</span><span class="si">}</span><span class="s2">-f_emb)/m&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">addComputePerDof</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;v + </span><span class="si">{</span><span class="n">fraction</span><span class="si">}</span><span class="s2">*dt*f</span><span class="si">{</span><span class="n">scale</span><span class="si">}</span><span class="s2">/m&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addComputePerDof</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;v + </span><span class="si">{</span><span class="n">fraction</span><span class="si">}</span><span class="s2">*dt*f/m&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_rattles</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">addConstrainVelocities</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_bath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fraction</span><span class="p">):</span>
        <span class="k">return</span></div>


<div class="viewcode-block" id="GeodesicLangevinIntegrator"><a class="viewcode-back" href="../../pythonapi/integrators.html#ufedmm.integrators.GeodesicLangevinIntegrator">[docs]</a><span class="k">class</span> <span class="nc">GeodesicLangevinIntegrator</span><span class="p">(</span><span class="n">AbstractMiddleRespaIntegrator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A geodesic Langevin integrator :cite:`Leimkuhler_2016`, which can be integrated by using</span>
<span class="sd">    either the LF-Middle or the VV-Middle scheme :cite:`Zhang_2019`.</span>

<span class="sd">    .. note:</span>
<span class="sd">        The VV-Middle scheme is also known as the BAOAB :cite:`Leimkuhler_2016` method.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        temperature : float or unit.Quantity</span>
<span class="sd">            The temperature.</span>
<span class="sd">        friction_coefficient : float or unit.Quantity</span>
<span class="sd">            The friction coefficient.</span>
<span class="sd">        step_size : float or unit.Quantity</span>
<span class="sd">            The time-step size.</span>

<span class="sd">    Keyword Args</span>
<span class="sd">    ------------</span>
<span class="sd">        num_rattles : int, default=1</span>
<span class="sd">            The number of RATTLE computations for geodesic integration :cite:`Leimkuhler_2016`.</span>
<span class="sd">            If ``num_rattles=0``, then no constraints are considered at all.</span>
<span class="sd">        scheme : str, default=&#39;LF-Middle&#39;</span>
<span class="sd">            Which splitting scheme will be used. Valid options are &#39;VV-Middle&#39; and &#39;LF-Middle&#39;.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            All other keyword arguments in :class:`AbstractMiddleRespaIntegrator`.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">        &gt;&gt;&gt; import ufedmm</span>
<span class="sd">        &gt;&gt;&gt; dt = 2*unit.femtoseconds</span>
<span class="sd">        &gt;&gt;&gt; temp = 300*unit.kelvin</span>
<span class="sd">        &gt;&gt;&gt; gamma = 10/unit.picoseconds</span>
<span class="sd">        &gt;&gt;&gt; ufedmm.GeodesicLangevinIntegrator(temp, gamma, dt, num_rattles=1, scheme=&#39;VV-Middle&#39;)</span>
<span class="sd">        Per-dof variables:</span>
<span class="sd">          kT, x0</span>
<span class="sd">        Global variables:</span>
<span class="sd">          friction = 10.0</span>
<span class="sd">        Computation steps:</span>
<span class="sd">           0: allow forces to update the context state</span>
<span class="sd">           1: v &lt;- v + 0.5*dt*f/m</span>
<span class="sd">           2: constrain velocities</span>
<span class="sd">           3: x &lt;- x + 0.5*dt*v</span>
<span class="sd">           4: x0 &lt;- x</span>
<span class="sd">           5: constrain positions</span>
<span class="sd">           6: v &lt;- v + (x - x0)/(0.5*dt)</span>
<span class="sd">           7: constrain velocities</span>
<span class="sd">           8: v &lt;- z*v + sqrt((1 - z*z)*kT/m)*gaussian; z = exp(-friction*1.0*dt)</span>
<span class="sd">           9: constrain velocities</span>
<span class="sd">          10: x &lt;- x + 0.5*dt*v</span>
<span class="sd">          11: x0 &lt;- x</span>
<span class="sd">          12: constrain positions</span>
<span class="sd">          13: v &lt;- v + (x - x0)/(0.5*dt)</span>
<span class="sd">          14: constrain velocities</span>
<span class="sd">          15: v &lt;- v + 0.5*dt*f/m</span>
<span class="sd">          16: constrain velocities</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">temperature</span><span class="p">,</span>
        <span class="n">friction_coefficient</span><span class="p">,</span>
        <span class="n">step_size</span><span class="p">,</span>
        <span class="n">num_rattles</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">scheme</span><span class="o">=</span><span class="s2">&quot;LF-Middle&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">temperature</span><span class="p">,</span> <span class="n">step_size</span><span class="p">,</span> <span class="n">num_rattles</span><span class="o">=</span><span class="n">num_rattles</span><span class="p">,</span> <span class="n">scheme</span><span class="o">=</span><span class="n">scheme</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addGlobalVariable</span><span class="p">(</span><span class="s2">&quot;friction&quot;</span><span class="p">,</span> <span class="n">friction_coefficient</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_bath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fraction</span><span class="p">):</span>
        <span class="n">expression</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;z*v + sqrt((1 - z*z)*kT/m)*gaussian; z = exp(-friction*</span><span class="si">{</span><span class="n">fraction</span><span class="si">}</span><span class="s2">*dt)&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addComputePerDof</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">expression</span><span class="p">)</span></div>


<div class="viewcode-block" id="MiddleMassiveNHCIntegrator"><a class="viewcode-back" href="../../pythonapi/integrators.html#ufedmm.integrators.MiddleMassiveNHCIntegrator">[docs]</a><span class="k">class</span> <span class="nc">MiddleMassiveNHCIntegrator</span><span class="p">(</span><span class="n">AbstractMiddleRespaIntegrator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A massive, middle-type Nose-Hoover Chain Thermostat solver :cite:`Martyna_1992`</span>
<span class="sd">    with optional multiple time-scale integration via RESPA.</span>

<span class="sd">    To enable RESPA, the forces in OpenMM system must be split into distinct force</span>
<span class="sd">    groups and the keyword ``respa_loop`` (see below) must be a list with multiple entries.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        temperature : float or unit.Quantity</span>
<span class="sd">            The temperature.</span>
<span class="sd">        time_constant : float or unit.Quantity</span>
<span class="sd">            The characteristic time constant.</span>
<span class="sd">        step_size : float or unit.Quantity</span>
<span class="sd">            The time-step size.</span>

<span class="sd">    Keyword Args</span>
<span class="sd">    ------------</span>
<span class="sd">        nchain : int, default=2</span>
<span class="sd">            The number of thermostats in each Nose-Hoover chain.</span>
<span class="sd">        track_energy : bool, default=False</span>
<span class="sd">            Whether to track the thermostat energy term.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            All keyword arguments in :class:`AbstractMiddleRespaIntegrator`, except ``num_rattles``.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">        &gt;&gt;&gt; import ufedmm</span>
<span class="sd">        &gt;&gt;&gt; temp, tau, dt = 300*unit.kelvin, 10*unit.femtoseconds, 2*unit.femtoseconds</span>
<span class="sd">        &gt;&gt;&gt; integrator = ufedmm.MiddleMassiveNHCIntegrator(temp, tau, dt, respa_loops=[4, 1], unroll_loops=False)</span>
<span class="sd">        &gt;&gt;&gt; print(integrator)</span>
<span class="sd">        Per-dof variables:</span>
<span class="sd">          kT, Q, v1, v2</span>
<span class="sd">        Global variables:</span>
<span class="sd">          irespa0 = 0.0</span>
<span class="sd">        Computation steps:</span>
<span class="sd">           0: allow forces to update the context state</span>
<span class="sd">           1: v &lt;- v + 0.5*dt*f1/m</span>
<span class="sd">           2: irespa0 &lt;- 0</span>
<span class="sd">           3: while (irespa0 &lt; 3.5):</span>
<span class="sd">           4:    v &lt;- v + 0.125*dt*f0/m</span>
<span class="sd">           5:    x &lt;- x + 0.125*dt*v</span>
<span class="sd">           6:    v2 &lt;- v2 + 0.125*dt*(Q*v1^2 - kT)/Q</span>
<span class="sd">           7:    v1 &lt;- (v1*z + 0.125*dt*(m*v^2 - kT)/Q)*z; z=exp(-0.0625*dt*v2)</span>
<span class="sd">           8:    v &lt;- v*exp(-0.25*dt*v1)</span>
<span class="sd">           9:    v1 &lt;- (v1*z + 0.125*dt*(m*v^2 - kT)/Q)*z; z=exp(-0.0625*dt*v2)</span>
<span class="sd">          10:    v2 &lt;- v2 + 0.125*dt*(Q*v1^2 - kT)/Q</span>
<span class="sd">          11:    x &lt;- x + 0.125*dt*v</span>
<span class="sd">          12:    v &lt;- v + 0.125*dt*f0/m</span>
<span class="sd">          13:    irespa0 &lt;- irespa0 + 1</span>
<span class="sd">          14: end</span>
<span class="sd">          15: v &lt;- v + 0.5*dt*f1/m</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">temperature</span><span class="p">,</span> <span class="n">time_constant</span><span class="p">,</span> <span class="n">step_size</span><span class="p">,</span> <span class="n">nchain</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">track_energy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;num_rattles&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;num_rattles&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> cannot handle constraints&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tau</span> <span class="o">=</span> <span class="n">_standardized</span><span class="p">(</span><span class="n">time_constant</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nchain</span> <span class="o">=</span> <span class="n">nchain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_track_energy</span> <span class="o">=</span> <span class="n">track_energy</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">temperature</span><span class="p">,</span> <span class="n">step_size</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addPerDofVariable</span><span class="p">(</span><span class="s2">&quot;Q&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nchain</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addPerDofVariable</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;v</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">track_energy</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">addPerDofVariable</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;eta</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update_temperatures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system_temperature</span><span class="p">,</span> <span class="n">extended_space_temperatures</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">update_temperatures</span><span class="p">(</span><span class="n">system_temperature</span><span class="p">,</span> <span class="n">extended_space_temperatures</span><span class="p">)</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_tau</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">kT</span> <span class="k">for</span> <span class="n">kT</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPerDofVariableByName</span><span class="p">(</span><span class="s2">&quot;kT&quot;</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setPerDofVariableByName</span><span class="p">(</span><span class="s2">&quot;Q&quot;</span><span class="p">,</span> <span class="n">Q</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_bath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fraction</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nchain</span>

        <span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;(Q*v</span><span class="si">{</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="si">}</span><span class="s2">^2 - kT)/Q&quot;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;(m*v^2 - kT)/Q&quot;</span>

        <span class="k">def</span> <span class="nf">z</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;exp(-</span><span class="si">{</span><span class="n">fraction</span><span class="o">/</span><span class="mi">4</span><span class="si">}</span><span class="s2">*dt*v</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">)&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">addComputePerDof</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;v</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;v</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> + </span><span class="si">{</span><span class="n">fraction</span><span class="o">/</span><span class="mi">2</span><span class="si">}</span><span class="s2">*dt*</span><span class="si">{</span><span class="n">a</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addComputePerDof</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;v</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;(v</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">*z + </span><span class="si">{</span><span class="n">fraction</span><span class="o">/</span><span class="mi">2</span><span class="si">}</span><span class="s2">*dt*</span><span class="si">{</span><span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="s2">)*z; z=</span><span class="si">{</span><span class="n">z</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addComputePerDof</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;v*exp(-</span><span class="si">{</span><span class="n">fraction</span><span class="si">}</span><span class="s2">*dt*v1)&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">addComputePerDof</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;v</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;(v</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">*z + </span><span class="si">{</span><span class="n">fraction</span><span class="o">/</span><span class="mi">2</span><span class="si">}</span><span class="s2">*dt*</span><span class="si">{</span><span class="n">a</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="s2">)*z; z=</span><span class="si">{</span><span class="n">z</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addComputePerDof</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;v</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;v</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> + </span><span class="si">{</span><span class="n">fraction</span><span class="o">/</span><span class="mi">2</span><span class="si">}</span><span class="s2">*dt*</span><span class="si">{</span><span class="n">a</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="MiddleMassiveGGMTIntegrator"><a class="viewcode-back" href="../../pythonapi/integrators.html#ufedmm.integrators.MiddleMassiveGGMTIntegrator">[docs]</a><span class="k">class</span> <span class="nc">MiddleMassiveGGMTIntegrator</span><span class="p">(</span><span class="n">AbstractMiddleRespaIntegrator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A massive, middle-type Generalized Gaussian Moment Thermostat :cite:`Liu_2000`</span>
<span class="sd">    solver with optional multiple time-scale integration via RESPA.</span>

<span class="sd">    To enable RESPA, the forces in OpenMM system must be split into distinct force</span>
<span class="sd">    groups and the keyword ``respa_loop`` (see below) must be a list with multiple entries.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        temperature : float or unit.Quantity</span>
<span class="sd">            The temperature.</span>
<span class="sd">        time_constant : float or unit.Quantity</span>
<span class="sd">            The characteristic time constant.</span>
<span class="sd">        step_size : float or unit.Quantity</span>
<span class="sd">            The time-step size.</span>

<span class="sd">    Keyword Args</span>
<span class="sd">    ------------</span>
<span class="sd">        **kwargs</span>
<span class="sd">            All keyword arguments in :class:`AbstractMiddleRespaIntegrator`, except ``num_rattles``.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">        &gt;&gt;&gt; import ufedmm</span>
<span class="sd">        &gt;&gt;&gt; temp, tau, dt = 300*unit.kelvin, 10*unit.femtoseconds, 2*unit.femtoseconds</span>
<span class="sd">        &gt;&gt;&gt; integrator = ufedmm.MiddleMassiveGGMTIntegrator(temp, tau, dt)</span>
<span class="sd">        &gt;&gt;&gt; print(integrator)</span>
<span class="sd">        Per-dof variables:</span>
<span class="sd">          kT, Q1, Q2, v1, v2</span>
<span class="sd">        Computation steps:</span>
<span class="sd">           0: allow forces to update the context state</span>
<span class="sd">           1: v &lt;- v + 0.5*dt*f/m</span>
<span class="sd">           2: x &lt;- x + 0.5*dt*v</span>
<span class="sd">           3: v1 &lt;- v1 + 0.5*dt*(m*v^2 - kT)/Q1</span>
<span class="sd">           4: v2 &lt;- v2 + 0.5*dt*((m*v^2)^2/3 - kT^2)/Q2</span>
<span class="sd">           5: v &lt;- v*exp(-1.0*dt*(v1 + kT*v2))/sqrt(1 + 2.0*dt*m*v^2*v2/3)</span>
<span class="sd">           6: v1 &lt;- v1 + 0.5*dt*(m*v^2 - kT)/Q1</span>
<span class="sd">           7: v2 &lt;- v2 + 0.5*dt*((m*v^2)^2/3 - kT^2)/Q2</span>
<span class="sd">           8: x &lt;- x + 0.5*dt*v</span>
<span class="sd">           9: v &lt;- v + 0.5*dt*f/m</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">temperature</span><span class="p">,</span> <span class="n">time_constant</span><span class="p">,</span> <span class="n">step_size</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;num_rattles&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;num_rattles&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> cannot handle constraints&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tau</span> <span class="o">=</span> <span class="n">_standardized</span><span class="p">(</span><span class="n">time_constant</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">temperature</span><span class="p">,</span> <span class="n">step_size</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addPerDofVariable</span><span class="p">(</span><span class="s2">&quot;Q1&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addPerDofVariable</span><span class="p">(</span><span class="s2">&quot;Q2&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addPerDofVariable</span><span class="p">(</span><span class="s2">&quot;v1&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addPerDofVariable</span><span class="p">(</span><span class="s2">&quot;v2&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_extended_space_time_constants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_constants</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_xs_taus</span> <span class="o">=</span> <span class="p">[</span><span class="n">_standardized</span><span class="p">(</span><span class="n">tau</span><span class="p">)</span> <span class="k">for</span> <span class="n">tau</span> <span class="ow">in</span> <span class="n">time_constants</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">update_temperatures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system_temperature</span><span class="p">,</span> <span class="n">extended_space_temperatures</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">update_temperatures</span><span class="p">(</span><span class="n">system_temperature</span><span class="p">,</span> <span class="n">extended_space_temperatures</span><span class="p">)</span>
        <span class="n">kT_vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPerDofVariableByName</span><span class="p">(</span><span class="s2">&quot;kT&quot;</span><span class="p">)</span>
        <span class="n">kT3_vectors</span> <span class="o">=</span> <span class="p">[</span><span class="n">openmm</span><span class="o">.</span><span class="n">Vec3</span><span class="p">(</span><span class="n">kT</span><span class="o">.</span><span class="n">x</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="n">kT</span><span class="o">.</span><span class="n">y</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="n">kT</span><span class="o">.</span><span class="n">z</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">kT</span> <span class="ow">in</span> <span class="n">kT_vectors</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_xs_taus&quot;</span><span class="p">):</span>
            <span class="n">num_particles</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">kT_vectors</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">extended_space_temperatures</span><span class="p">)</span>
            <span class="n">taus</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_tau</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_particles</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xs_taus</span>
            <span class="n">Q1</span> <span class="o">=</span> <span class="p">[</span><span class="n">kT</span> <span class="o">*</span> <span class="n">tau</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">kT</span><span class="p">,</span> <span class="n">tau</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">kT_vectors</span><span class="p">,</span> <span class="n">taus</span><span class="p">)]</span>
            <span class="n">Q2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">kT3</span> <span class="o">*</span> <span class="n">tau</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">kT3</span><span class="p">,</span> <span class="n">tau</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">kT3_vectors</span><span class="p">,</span> <span class="n">taus</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Q1</span> <span class="o">=</span> <span class="p">[</span><span class="n">kT</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tau</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">kT</span> <span class="ow">in</span> <span class="n">kT_vectors</span><span class="p">]</span>
            <span class="n">Q2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">kT3</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tau</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">kT3</span> <span class="ow">in</span> <span class="n">kT3_vectors</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setPerDofVariableByName</span><span class="p">(</span><span class="s2">&quot;Q1&quot;</span><span class="p">,</span> <span class="n">Q1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setPerDofVariableByName</span><span class="p">(</span><span class="s2">&quot;Q2&quot;</span><span class="p">,</span> <span class="n">Q2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_bath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fraction</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addComputePerDof</span><span class="p">(</span><span class="s2">&quot;v1&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;v1 + </span><span class="si">{</span><span class="n">fraction</span><span class="o">/</span><span class="mi">2</span><span class="si">}</span><span class="s2">*dt*(m*v^2 - kT)/Q1&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addComputePerDof</span><span class="p">(</span><span class="s2">&quot;v2&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;v2 + </span><span class="si">{</span><span class="n">fraction</span><span class="o">/</span><span class="mi">2</span><span class="si">}</span><span class="s2">*dt*((m*v^2)^2/3 - kT^2)/Q2&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addComputePerDof</span><span class="p">(</span>
            <span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;v*exp(-</span><span class="si">{</span><span class="n">fraction</span><span class="si">}</span><span class="s2">*dt*(v1 + kT*v2))/sqrt(1 + </span><span class="si">{</span><span class="mi">2</span><span class="o">*</span><span class="n">fraction</span><span class="si">}</span><span class="s2">*dt*m*v^2*v2/3)&quot;</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addComputePerDof</span><span class="p">(</span><span class="s2">&quot;v1&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;v1 + </span><span class="si">{</span><span class="n">fraction</span><span class="o">/</span><span class="mi">2</span><span class="si">}</span><span class="s2">*dt*(m*v^2 - kT)/Q1&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addComputePerDof</span><span class="p">(</span><span class="s2">&quot;v2&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;v2 + </span><span class="si">{</span><span class="n">fraction</span><span class="o">/</span><span class="mi">2</span><span class="si">}</span><span class="s2">*dt*((m*v^2)^2/3 - kT^2)/Q2&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="RegulatedNHLIntegrator"><a class="viewcode-back" href="../../pythonapi/integrators.html#ufedmm.integrators.RegulatedNHLIntegrator">[docs]</a><span class="k">class</span> <span class="nc">RegulatedNHLIntegrator</span><span class="p">(</span><span class="n">AbstractMiddleRespaIntegrator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A regulated version of the massive Nose-Hoover-Langevin :cite:`Samoletov_2007,Leimkuhler_2009`</span>
<span class="sd">    method. Regulation means that the system Hamiltonian is modified so that velocities remain below</span>
<span class="sd">    a temperature-dependent limit. This is closely related to the SIN(R) method :cite:`Leimkuhler_2013`</span>
<span class="sd">    and allows multiple time-scale integration with very large outer time steps, without resonance.</span>

<span class="sd">    .. info:</span>
<span class="sd">        If `regulation_parameter = 1` (default), this method is equivalent to SIN(R) with a single</span>
<span class="sd">        thermostat per degree of freedom (that is, `L=1`).</span>

<span class="sd">    The following :term:`SDE` system is solved for every degree of freedom in the system:</span>

<span class="sd">    .. math::</span>
<span class="sd">        &amp; dr_i = v_i dt \\\\</span>
<span class="sd">        &amp; dp_i = F_i dt - v_{\\eta_i} m_i v_i dt \\\\</span>
<span class="sd">        &amp; dv_{\\eta_i} = \\frac{1}{Q}\\left(\\frac{n+1}{n} m_i v_i^2 - k_B T\\right) dt</span>
<span class="sd">                - \\gamma v_{\\eta_i} dt + \\sqrt{\\frac{2\\gamma k_B T}{Q}} dW_i,</span>

<span class="sd">    where:</span>

<span class="sd">    .. math::</span>
<span class="sd">        v_i = c_i \\tanh\\left(\\frac{p_i}{m_i c_i}\\right).</span>

<span class="sd">    Here, :math:`n` is the regulation parameter and :math:`c_i = \\sqrt{\\frac{n k T}{m_i}}` is</span>
<span class="sd">    the maximum speed for degree of freedom `i`. The inertial parameter :math:`Q` is defined as</span>
<span class="sd">    :math:`Q = n k_B T \\tau^2`, with :math:`\\tau` being a relaxation time :cite:`Tuckerman_1992`.</span>
<span class="sd">    An approximate solution is obtained by applying the Trotter-Suzuki splitting formula:</span>

<span class="sd">    .. math::</span>
<span class="sd">        e^{\\Delta t\\mathcal{L}} =</span>
<span class="sd">        e^{\\frac{\\Delta t}{2}\\mathcal{L}^1_p}</span>
<span class="sd">        \\left[e^{\\frac{\\delta t}{2}\\mathcal{L}^0_p}</span>
<span class="sd">        e^{\\frac{\\delta t}{2}\\mathcal{L}_r}</span>
<span class="sd">        e^{\\delta t \\mathcal{L}_\\mathrm{bath}}</span>
<span class="sd">        e^{\\frac{\\delta t}{2}\\mathcal{L}_r}</span>
<span class="sd">        e^{\\frac{\\delta t}{2}\\mathcal{L}^0_p}\\right]^m</span>
<span class="sd">        e^{\\frac{\\Delta t}{2}\\mathcal{L}^1_p}</span>

<span class="sd">    where :math:`\\delta t = \\frac{\\Delta t}{m}`. Each exponential operator above is the solution</span>
<span class="sd">    of a differential equation.</span>

<span class="sd">    The exact solution for the physical-system part is:</span>

<span class="sd">    .. math::</span>
<span class="sd">        r_i(t) = r_i^0 + c_i \\mathrm{tanh}\\left(\\frac{p_i}{m c_i}\\right) t</span>

<span class="sd">    .. math::</span>
<span class="sd">        p_i(t) = p_i^0 + F_i t</span>

<span class="sd">    The bath propagator is further split as:</span>

<span class="sd">    .. math::</span>
<span class="sd">        e^{\\delta t \\mathcal{L}_\\mathrm{bath}} =</span>
<span class="sd">        e^{\\frac{\\delta t}{2m}\\mathcal{L}_B}</span>
<span class="sd">        e^{\\frac{\\delta t}{2m}\\mathcal{L}_S}</span>
<span class="sd">        e^{\\frac{\\delta t}{m}\\mathcal{L}_O}</span>
<span class="sd">        e^{\\frac{\\delta t}{2m}\\mathcal{L}_S}</span>
<span class="sd">        e^{\\frac{\\delta t}{2m}\\mathcal{L}_B}</span>

<span class="sd">    Part &#39;B&#39; is a boost, whose solution is:</span>

<span class="sd">    .. math::</span>
<span class="sd">        v_{\\eta_i}(t) = v_{\\eta_i}^0 +</span>
<span class="sd">                         \\frac{1}{Q}\\left(\\frac{n+1}{n} m_i v_i^2 - k_B T\\right) t</span>

<span class="sd">    Part &#39;S&#39; is a scaling, whose solution is:</span>

<span class="sd">    .. math::</span>
<span class="sd">        p_i(t) = m_i c_i \\mathrm{arcsinh}\\left[</span>
<span class="sd">                    \\sinh\\left(\\frac{p_i^0}{m_i c_i}\\right) e^{- v_{\\eta_i} t}</span>
<span class="sd">                 \\right]</span>

<span class="sd">    Part &#39;O&#39; is an OrnsteinUhlenbeck process, whose solution is:</span>

<span class="sd">    .. math::</span>
<span class="sd">        v_{\\eta_i}(t) = v_{\\eta_i}^0 e^{-\\gamma t}</span>
<span class="sd">                   + \\sqrt{\\frac{k_B T}{Q}(1-e^{-2\\gamma t})} R_N</span>

<span class="sd">    where :math:`R_N` is a normally distributed random number.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        step_size : float or unit.Quantity</span>
<span class="sd">            The outer step size with which to integrate the equations of motion.</span>
<span class="sd">        loops : int</span>
<span class="sd">            The number of internal substeps at each time step.</span>
<span class="sd">        temperature : unit.Quantity</span>
<span class="sd">            The temperature of the heat bath.</span>
<span class="sd">        time_scale : unit.Quantity (time)</span>
<span class="sd">            The relaxation time (:math:`\\tau`) of the Nose-Hoover thermostat.</span>
<span class="sd">        friction_coefficient : unit.Quantity (1/time)</span>
<span class="sd">            The friction coefficient (:math:`\\gamma`) of the Langevin thermostat.</span>
<span class="sd">        regulation_parameter : int or float</span>
<span class="sd">            The regulation parameter n.</span>

<span class="sd">    Keyword Args</span>
<span class="sd">    ------------</span>
<span class="sd">        semi_regulated : bool, default=True</span>
<span class="sd">            Whether to use the semi-regulated NHL version of the method instead of its</span>
<span class="sd">            fully-regulated version.</span>
<span class="sd">        split_ornstein_uhlenbeck : bool, default=True</span>
<span class="sd">            Whether to split the drifted Ornstein-Uhlenbeck operator.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            All keyword arguments in :class:`AbstractMiddleRespaIntegrator`, except ``num_rattles``.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">temperature</span><span class="p">,</span>
        <span class="n">time_constant</span><span class="p">,</span>
        <span class="n">friction_coefficient</span><span class="p">,</span>
        <span class="n">step_size</span><span class="p">,</span>
        <span class="n">regulation_parameter</span><span class="p">,</span>
        <span class="n">semi_regulated</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">split_ornstein_uhlenbeck</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;num_rattles&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;num_rattles&quot;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> cannot handle constraints&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tau</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">regulation_parameter</span><span class="p">)</span> <span class="o">*</span> <span class="n">time_constant</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n</span> <span class="o">=</span> <span class="n">regulation_parameter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_split</span> <span class="o">=</span> <span class="n">split_ornstein_uhlenbeck</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_semi_regulated</span> <span class="o">=</span> <span class="n">semi_regulated</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">temperature</span><span class="p">,</span> <span class="n">step_size</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addPerDofVariable</span><span class="p">(</span><span class="s2">&quot;invQ&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addPerDofVariable</span><span class="p">(</span><span class="s2">&quot;v_eta&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addPerDofVariable</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addGlobalVariable</span><span class="p">(</span><span class="s2">&quot;friction&quot;</span><span class="p">,</span> <span class="n">friction_coefficient</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addGlobalVariable</span><span class="p">(</span><span class="s2">&quot;omega&quot;</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tau</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addGlobalVariable</span><span class="p">(</span><span class="s2">&quot;aa&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addGlobalVariable</span><span class="p">(</span><span class="s2">&quot;bb&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">update_temperatures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system_temperature</span><span class="p">,</span> <span class="n">extended_space_temperatures</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">update_temperatures</span><span class="p">(</span><span class="n">system_temperature</span><span class="p">,</span> <span class="n">extended_space_temperatures</span><span class="p">)</span>
        <span class="n">kT_vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getPerDofVariableByName</span><span class="p">(</span><span class="s2">&quot;kT&quot;</span><span class="p">)</span>
        <span class="n">tauSq</span> <span class="o">=</span> <span class="n">_standardized</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tau</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">Q</span> <span class="o">=</span> <span class="p">[</span><span class="n">tauSq</span> <span class="o">*</span> <span class="n">kT</span> <span class="k">for</span> <span class="n">kT</span> <span class="ow">in</span> <span class="n">kT_vectors</span><span class="p">]</span>
        <span class="n">invQ</span> <span class="o">=</span> <span class="p">[</span><span class="n">openmm</span><span class="o">.</span><span class="n">Vec3</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">Q</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setPerDofVariableByName</span><span class="p">(</span><span class="s2">&quot;invQ&quot;</span><span class="p">,</span> <span class="n">invQ</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_step_initialization</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addComputePerDof</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;sqrt(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="si">}</span><span class="s2">*kT/m)&quot;</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_respa_loops</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bath_loops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addComputeGlobal</span><span class="p">(</span><span class="s2">&quot;aa&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;exp(-friction*dt/</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addComputeGlobal</span><span class="p">(</span><span class="s2">&quot;bb&quot;</span><span class="p">,</span> <span class="s2">&quot;omega*sqrt(1-aa^2)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_translation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fraction</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_semi_regulated</span><span class="p">:</span>
            <span class="n">expression</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;0.5*m*v*c*tanh(v/c); c=sqrt(</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">*kT/m)&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">expression</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">n</span><span class="si">}</span><span class="s2">*m*(c*tanh(v/c))^2; c=sqrt(</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">*kT/m)&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setKineticEnergyExpression</span><span class="p">(</span><span class="n">expression</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addComputePerDof</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;x + c*tanh(v/c)*</span><span class="si">{</span><span class="n">fraction</span><span class="si">}</span><span class="s2">*dt&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_bath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fraction</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_semi_regulated</span><span class="p">:</span>
            <span class="n">G</span> <span class="o">=</span> <span class="s2">&quot;; G=(m*v*c*tanh(v/c) - kT)*invQ&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">G</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;; G=(</span><span class="si">{</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">n</span><span class="si">}</span><span class="s2">*m*(c*tanh(v/c))^2 - kT)*invQ&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split</span><span class="p">:</span>
            <span class="n">boost</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;v_eta + G*</span><span class="si">{</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fraction</span><span class="si">}</span><span class="s2">*dt&quot;</span> <span class="o">+</span> <span class="n">G</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_semi_regulated</span><span class="p">:</span>
            <span class="n">scaling</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;v*exp(-v_eta*</span><span class="si">{</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fraction</span><span class="si">}</span><span class="s2">*dt)&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scaling</span> <span class="o">=</span> <span class="s2">&quot;c*asinh_z&quot;</span>
            <span class="n">scaling</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="s2">&quot;; asinh_z=(2*step(z)-1)*log(select(step(za-1E8),2*za,za+sqrt(1+z*z))); za=abs(z)&quot;</span>
            <span class="p">)</span>
            <span class="n">scaling</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;; z=sinh(v/c)*exp(-v_eta*</span><span class="si">{</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fraction</span><span class="si">}</span><span class="s2">*dt)&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split</span><span class="p">:</span>
            <span class="n">Ornstein_Uhlenbeck</span> <span class="o">=</span> <span class="s2">&quot;v_eta*aa + bb*gaussian&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Ornstein_Uhlenbeck</span> <span class="o">=</span> <span class="s2">&quot;v_eta*aa + G*(1-aa)/friction + bb*gaussian&quot;</span> <span class="o">+</span> <span class="n">G</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_split</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">addComputePerDof</span><span class="p">(</span><span class="s2">&quot;v_eta&quot;</span><span class="p">,</span> <span class="n">boost</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addComputePerDof</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">scaling</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addComputePerDof</span><span class="p">(</span><span class="s2">&quot;v_eta&quot;</span><span class="p">,</span> <span class="n">Ornstein_Uhlenbeck</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addComputePerDof</span><span class="p">(</span><span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="n">scaling</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_split</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">addComputePerDof</span><span class="p">(</span><span class="s2">&quot;v_eta&quot;</span><span class="p">,</span> <span class="n">boost</span><span class="p">)</span></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">UFED for OpenMM</a></h1>











<h3><a href="../../index.html">Table of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../pythonapi/index.html">Python API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../references.html">Bibliography</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Charlles Abreu. Project structure based on the Computational Molecular Science Python Cookiecutter version 1.0.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>